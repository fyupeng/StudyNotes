自我介绍这里一笔带过，给对面介绍自己内在 + 外在 + 校园经历 + 校园项目  + 意向岗位

腾讯子公司云智研发一面

### 1. 有了解过C++吗？接受转语言吗？

### 2. 有没有了解过一些框架的底层原理、底层优化、数据库的索引优化

### 3. 了解过哪些Map，可以从底层简单说下嘛？

比如我最常使用的有`HashMap`、`HashTable`、`CurrentHashMap`这三种

`HashMap`它的底层是采用了数组+链表的数据结构

从源码中分析，`HashMap`有一个静态内部类`Node`，`HashMap`通过成员变量`table`（`Node`数组类型）来采取`put`和`get`操作，该成员变量用关键字`transient`加以修饰，表明禁止序列化。

而`Node`是`table`数组的一个结点，内部成员数据有`hash`、`key`、`value`和指向`Node`类的`next`

> -- 初始化阶段 --

在这里，`put`操作后，`table`会先调用`resize`方法进行扩展，扩展后`table`才从`null`变为`16`位的`Node`数组，初始化后的每一个下标依旧为`null`，并且初始化阈值`threshold`，默认为`0.75 * size`,作用是与成员变量`size`（成员变量`size`会在每次`put`而且要该`key`值为首次操作即不存在该`Map`中会自增）进行比较，如果`size`数即表明`put`的`key-value`对的数量超过阈值`threshold`，进行下一步操作，即`resize`方法另一作用。

> -- 扩容阶段 --

扩容阶段更简单，就是将`阈值*2`来扩容，然后遍历整个`table`即`Node`数组，如果发现有`Node`结点，那么这里就出现了两种情况，第一种为每个结点上是链表结构，另一种则是红黑树结构



当然刚开始没有结点数据，`oldTable`为`null`，不需要转移结点，然后什么事都没干，接着通过`hash`与`table`的长度进行`&`操作命中槽位，`put`操作会保存到数组对应下标处即槽位中的结点。

> -- 结点初始化 --

保存之前很简单，得判断对应`Node`数组下标结点是否为`null`，因为这里是懒加载嘛，刚开始没有初始化数组的每一个元素，`resize`初始化方法也只是`new`了个`Node`数组，而且这也一样是懒加载。

所以在这里会将`put`中`key`的`hash、key和value`值封装到`Node`结点中并实例化，然后赋值到对应的`Node`数组下标中。

如果结点已经实例化了，那么这里有两种方式，一是链表寻址，二是树寻址，然后就是找到就覆盖，找不到就追加。

> -- 链表寻址 --

寻址前会先判断结点类型，如果`instanceof`不是`TreeNode`，那么便是链表，然后就可以开始遍历链表了，如果找到了的话，`key-value`当然就是要覆盖了，但是这里对`key`的处理分为了两种：

分析之前，其实链表中所有结点都位于同一个数组下标，那么应该都必须满足每个结点的`hash`值相同，即槽位相同，所以会再一次判断`hash`值，才会用`key`去比较。

- 如果`key`为基本数据类型，那么是直接通过运算符`==`来比较的，为`true`，那么就直接跳出链表遍历了，然后将刚刚在链表访问后命中的`Node`结点`value`覆盖
- 如果key为复杂类型，那么仅仅通过`==`运算符比较是错误的，这里就需要我们去主动重写`equals`方法，让`key`值怎么比较才能相等，因为默认`equals`是`Object`比较，这里涉及到内存指针了，所以创建的对象一般内存都不同，除非浅拷贝。
- 只是我们一般都用`String`类型，而`String`类型已经帮我们重写过了，虽然`String`类型也算是复杂类型，它重写了`Object`的`equals`方法，使得不同对象可以进行比较，比较的是对应字符串序列的内容是否相同。

如果没找到，那么将实例化新的`Node`结点，然后追加到链表末尾，在`JDK7`中是追加到头结点，后来发现线程安全，即多线程情况下，有几率会导致链表出现死锁。

> -- 树寻址 --



首先了解下`TreeNode`，它继承了`LinkedHashMap.Entry`，而`Entry`又继承了`HashMap.Node`，归根结底还是跟链表的`Node`类似，只不过多了一些成员和方法。





> -- 链表转移 --

链表转移前会判断链表是否只有表头，即只有一个元素，那么通过寻找该结点`Node`的`Hash`值，与扩容后的`lenth`长度`&`操作命中新的槽位

```java
/**
e : table即Node数组中的一个下标元素
newCap: 新table的容量
e.hash: 哈希值，常用于与table长度做&操作来命中寻址
newTab: 新table
*/
newTab[e.hash & (newCap - 1)] = e;
```

如果是链表结构，那么按照`hash`值对链表拆成高位和低位链表，这里的高低位不是字面意思，我是直译源码字面意思，从代码分析：

```java
/** 
如果 hash 二进制数中 与 旧table的容量表示的二进制数 所在的 位为1 & 为 真，则表示为高位链表
如果 hash 二进制数中 与 旧table的容量表示的二进制数 所在的 位为1 & 为 假，则表示为低位链表
从随机性角度考虑，这两种散列均匀的话各占一半
hash: 4字节的 int 类型
oldCap: 4字节的 int 类型，默认初始化为 16，二进制表示为 10000
*/
e.hash & oldCap) == 0
```

由于新`table`是旧`table`的两倍，那么低位链表命中赋值给新`table`中与旧`table`相同的下标，而高位从字面上理解，就要比低位更靠右，所以它的下标是`原下标+oldCap`，`oldCap`大小也是新`table`大小的一半，看图

![HashMap扩容图](https://yupeng-tuchuang.oss-cn-shenzhen.aliyuncs.com/image-20221116225644342.png)



> -- 树转移 --







为了保证put操作，即将对应的Node结点保存到

### 4. 你项目中是如何去实现幂等性的？

先说下我对幂等性的理解，这样再去理解我项目对幂等性的处理。

首先

最后面试官说到对幂等性处理后的历史结果保存后，对事件触发后做相应的记录删除



### 5. RPC的协议讲一讲，怎么处理的？



### 6. 项目中是怎么序列化的？



### 7.说一说深拷贝和浅拷贝



### 8. TCP和UDP了解下？



### 9. Http底层使用了什么？

使用了`TCP`协议

因为`Http`是长连接可靠的连接，这是`http1.1`引入的

1.0没有长连接，每次请求都需要重新建立`tcp`连接，请求完成后立即断开与服务器连接，这很大程度上造成了性能上的缺陷，`http1.0`被抱怨最多的就是连接无法复用。

但1.1还是不能同时处理多个请求，还是要串行排队处理，于是推出2.0

2.0不像

### 10. 三次挥手说下？



### 11. 进程和线程的关系？



### 12. 了解过CAS嘛？



### 13. 你的RPC项目怎么怎么划分模块的？

主要由客户端、注册中心、服务端这三部分组成

服务端：负责向注册中心注册服务，接收客户端的访问处理相应的业务方法并返回结果；

客户端：负责从注册中心发现服务，获取服务对应的ip地址和端口，然后通过负载策略去调用







### 14. 做一套算法题

如有升序链表：list1 = [1,2,3]，list2 = [1,4,5]，则合并后的链表：list = [1,1,2,3,4,5]

```java
private List concat(List list1, List list2) {
	// 头结点存储数据
	List p = list1;
	List q = list2;
	
	List newNode = new List();
	List head = newNode;
	while(p.next != null && q.next != null) {
		if (p.data < q.data) {
			newNode.next = p;
			p = p.next;
		} else {
			newNode.next = q;
			q = q.next;
		}
		newNode = newNode.next;
	}
    // list2 仍存在节点
	if (p.next == null && q.next != null) {
		newNode.next = q;
	}
    // list1 仍存在节点
	if (p.next != null && q.next == null) {
		newNode.next = p;
	}
	return head.next;
}
```

