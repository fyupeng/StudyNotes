自我介绍这里一笔带过，给对面介绍自己内在 + 外在 + 校园经历 + 校园项目  + 意向岗位

腾讯子公司云智研发一面

围绕项目展开面试

### 1. 有了解过C++吗？接受转语言吗？

### 2. 有没有了解过一些框架的底层原理、底层优化、数据库的索引优化

### 3. 了解过哪些Map，可以从底层简单说下嘛？

比如我最常使用的有`HashMap`、`HashTable`、`CurrentHashMap`这三种

`HashMap`它的底层是采用了数组+链表的数据结构

从源码中分析，`HashMap`有一个静态内部类`Node`，`HashMap`通过成员变量`table`（`Node`数组类型）来采取`put`和`get`操作，该成员变量用关键字`transient`加以修饰，表明禁止序列化。

而`Node`是`table`数组的一个结点，内部成员数据有`hash`、`key`、`value`和指向`Node`类的`next`

> -- 初始化阶段 --

在这里，`put`操作后，`table`会先调用`resize`方法进行扩展，扩展后`table`才从`null`变为`16`位的`Node`数组，初始化后的每一个下标依旧为`null`，并且初始化阈值`threshold`，默认为`0.75 * size`,作用是与成员变量`size`（成员变量`size`会在每次`put`而且要该`key`值为首次操作即不存在该`Map`中会自增）进行比较，如果size数即表明put的key-value对的数量超过阈值`threshold`，进行下一步操作，即`resize`方法另一作用

> -- 扩容阶段 --

扩容阶段更简单，就是将`阈值*2`来扩容，然后遍历整个`table`即`Node`数组，如果发现有Node结点，那么这里就出现了两种情况，第一种为每个结点上是链表结构，另一种则是红黑树结构

> -- 链表转移 --

链表转移前会判断链表是否只有表头，即只有一个元素，那么通过寻找该结点`Node`的`Hash`值，与扩容后的`lenth`长度`&`操作命中新的槽位

```java
/**
e : table即Node数组中的一个下标元素
newCap: 新table的容量
e.hash: 哈希值，常用于与table长度做&操作来命中寻址
newTab: 新table
*/
newTab[e.hash & (newCap - 1)] = e;
```

如果是链表结构，那么按照hash值对链表拆成高位和低位链表，这里的高低位不是字面意思，我是直译源码字面意思，从代码分析：

```java
/** 
如果 hash 二进制数中 与 旧table的容量表示的二进制数 所在的 位为1 & 为 真，则表示为高位链表
如果 hash 二进制数中 与 旧table的容量表示的二进制数 所在的 位为1 & 为 假，则表示为低位链表
从随机性角度考虑，这两种散列均匀的话各占一半
hash: 4字节的 int 类型
oldCap: 4字节的 int 类型，默认初始化为 16，二进制表示为 10000
*/
e.hash & oldCap) == 0
```

由于新`table`是旧`table`的两倍，那么低位链表命中赋值给新`table`中与旧table相同的下标，而高位从字面上理解，就要比低位更靠右，所以它的下标是`原下标+oldCap`，`oldCap`大小也是新`table`大小的一半，看图

![HashMap扩容图](https://yupeng-tuchuang.oss-cn-shenzhen.aliyuncs.com/image-20221116225644342.png)





为了保证put操作，即将对应的Node结点保存到

### 4. 你项目中是如何去实现幂等性的？

先说下我对幂等性的理解，这样再去理解我项目对幂等性的处理。

首先

最后面试官说到对幂等性处理后的历史结果保存后，对事件触发后做相应的记录删除



### 5. RPC的协议讲一讲，怎么处理的？



### 6. 项目中是怎么序列化的？



### 7.说一说深拷贝和浅拷贝



### 8. TCP和UDP了解下？



### 9. Http底层使用了什么？

使用了`TCP`协议

因为`Http`是长连接可靠的连接，这是`http1.1`引入的

1.0没有长连接，每次请求都需要重新建立`tcp`连接，请求完成后立即断开与服务器连接，这很大程度上造成了性能上的缺陷，`http1.0`被抱怨最多的就是连接无法复用。

但1.1还是不能同时处理多个请求，还是要串行排队处理，于是推出2.0

2.0不像

### 10. 三次挥手说下？



### 11. 进程和线程的关系？



### 12. 了解过CAS嘛？



### 13. 你的RPC项目怎么怎么划分模块的？

主要由客户端、注册中心、服务端这三部分组成

服务端：负责向注册中心注册服务，接收客户端的访问处理相应的业务方法并返回结果；

客户端：负责从注册中心发现服务，获取服务对应的ip地址和端口，然后通过负载策略去调用







### 14. 做一套算法题

如有升序链表：list1 = [1,2,3]，list2 = [1,4,5]，则合并后的链表：list = [1,1,2,3,4,5]

```java
private List concat(List list1, List list2) {
	// 头结点存储数据
	List p = list1;
	List q = list2;
	
	List newNode = new List();
	List head = newNode;
	while(p.next != null && q.next != null) {
		if (p.data < q.data) {
			newNode.next = p;
			p = p.next;
		} else {
			newNode.next = q;
			q = q.next;
		}
		newNode = newNode.next;
	}
    // list2 仍存在节点
	if (p.next == null && q.next != null) {
		newNode.next = q;
	}
    // list1 仍存在节点
	if (p.next != null && q.next == null) {
		newNode.next = p;
	}
	return head.next;
}
```

